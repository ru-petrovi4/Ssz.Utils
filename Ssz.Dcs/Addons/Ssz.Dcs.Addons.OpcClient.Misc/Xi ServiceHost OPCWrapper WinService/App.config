<?xml version="1.0"?>
<!-- /**********************************************************************
 * Copyright Â© 2009, 2010, 2011, 2012 OPC Foundation, Inc. 
 *
 * The source code and all binaries built with the OPC .NET 3.0 source
 * code are subject to the terms of the Express Interface Public
 * License (Xi-PL).  See http://www.opcfoundation.org/License/Xi-PL/
 *
 * The source code may be distributed from an OPC member company in
 * its original or modified form to its customers and to any others who
 * have software that needs to interoperate with the OPC member's OPC
* .NET 3.0 products. No other redistribution is permitted.
 *
 * You must not remove this notice, or any other, from this software.
 *
 *********************************************************************/-->
<configuration>
	<appSettings>
	    <!-- Trace Levels (records in log file): All, Off, Critical, Error, Warning, Information, Verbose, ActivityTracing -->
	    <add key="LogLevels" value="Error"/>
        <add key="DebugLogLevels" value="Verbose"/>
        <add key="LogFilePath" value="%ProgramData%\Simcode\Logs"/>
		<!--Set the name of your company and the name of your server-->
		<add key="Vendor" value="Simcode"/>
		<add key="Server" value="SimcodeOpcNetServer"/>

		<!--Add site specific info (e.g. location of the server). 
		This info is used only for display purposes
		<add key="UserInfo" value="Deployment Specific Info"/>-->

		<!--If the server provides access to a single system only, 
			add this key and the name of the system.  The system is 
			the underlying system to which the native Xi server or the 
			wrapped OPC COM server provides access.  The system 
			name is used by clients to differentiate Xi InstanceIds
			obtained from multiple Xi Servers. The SystemName will 
			be embedded in the InstanceIds of this server.
		<add key="System" value="This System Name"/>-->

		<!--The following keys contain the ProgIds for the wrapped servers.
		Comment out the unused entries-->
		<add key="OPCDA" value="Uso.OpcDAServer"/>
		<add key="OPCAE" value="Uso.OpcAEServer"/>
		<add key="USOHDA" value="Uso.OpcHdaServer"/>

		<!--The following keys contain the Machine Names/IP Addresses 
		for the wrapped servers. Leave them commented out if they are 
		on the same machine as the Wrapper-->
		<!--<add key="OPCDAHOST" value ="MachineName"/>-->
		<!--<add key="OPCAEHOST" value ="MachineName"/>-->
		<!--<add key="OPCHDAHOST" value ="MachineName"/>-->
	</appSettings>

	<system.serviceModel>
		<diagnostics>
			<messageLogging logEntireMessage="true" logMalformedMessages="true" logMessagesAtServiceLevel="false" logMessagesAtTransportLevel="true"/>
		</diagnostics>

		<services>
			<service name="Xi.OPC.Wrapper.Impl.XiOPCWrapper" behaviorConfiguration="XiServer">

				<!--MEX Endpoint-->
				<endpoint address="mex" binding="mexHttpBinding" name="metaData" contract="IMetadataExchange"/>

				<!--Server Discovery Endpoint-->
				<!--Set the URL below.  This URL must be an http URL and the basicHttpBinding must be used.
				The port number in the URL may be changed to create a unique URL.Alternatively, the port number 
				may be shared with other servers as long as the path following the port number is unique to the server.  
				This URL should be copied to the manual configuration file of the Discovery Server when PNRP is 
				not used for server discovery. -->
				<endpoint address="ServerDiscovery" binding="basicHttpBinding" name="serverDiscovery" contract="Xi.Contracts.IServerDiscovery"/>

				<!--netNamedPipeBinding Endpoints
				<endpoint address="ResourceManagement" binding="netNamedPipeBinding" bindingConfiguration="NetPipeSecure" name="pipeResMgt" bindingName="" contract="Xi.Contracts.IResourceManagement"/>

				<endpoint address="Read" binding="netNamedPipeBinding" bindingConfiguration="netPipe" name="pipeRead" bindingName="" contract="Xi.Contracts.IRead"/>

				<endpoint address="Write" binding="netNamedPipeBinding" bindingConfiguration="netPipe" name="pipeWrite" bindingName="" contract="Xi.Contracts.IWrite"/>

				<endpoint address="Callback" binding="netNamedPipeBinding" bindingConfiguration="netPipe" name="pipeCallback" bindingName="" contract="Xi.Contracts.IRegisterForCallback"/>
                -->

				<!--netTcpBinding Default Endpoints-->
				<endpoint address="ResourceManagement" binding="netTcpBinding" bindingConfiguration="netTcp" name="tcpResMgt" bindingName="" contract="Xi.Contracts.IResourceManagement"/>

				<endpoint address="Read" binding="netTcpBinding" bindingConfiguration="netTcp" name="tcpRead" bindingName="" contract="Xi.Contracts.IRead"/>

				<endpoint address="Write" binding="netTcpBinding" bindingConfiguration="netTcp" name="tcpWrite" bindingName="" contract="Xi.Contracts.IWrite"/>

				<endpoint address="Callback" binding="netTcpBinding" bindingConfiguration="netTcp" name="tcpCallback" bindingName="" contract="Xi.Contracts.IRegisterForCallback"/>
				
                <!--
				<endpoint address="Poll" binding="netTcpBinding" bindingConfiguration="netTcp" name="tcpPoll" bindingName="" contract="Xi.Contracts.IPoll"/>
                -->

				<!--netTcpBinding Additional Read/Write/Subscribe Endpoints-->
				<!--<endpoint address="ReadSecure" binding="netTcpBinding" bindingConfiguration="netTcpSecure"
				name="tcpReadSecure" bindingName="" contract="Xi.Contracts.IRead" />

				<endpoint address="WriteSecure" binding="netTcpBinding" bindingConfiguration="netTcpSecure"
				name="tcpWriteSecure" bindingName="" contract="Xi.Contracts.IWrite" />

				<endpoint address="CallbackSecure" binding="netTcpBinding" bindingConfiguration="netTcpSecure"
				name="tcpCallbackSecure" bindingName="" contract="Xi.Contracts.IRegisterForCallback" />-->

				<!--wsHttpBinding Endpoints
				<endpoint address="ResourceManagement" binding="wsHttpBinding" bindingConfiguration="wsHttp" name="wsHttpResMgt" bindingName="" contract="Xi.Contracts.IResourceManagement"/>

				<endpoint address="Read" binding="wsHttpBinding" bindingConfiguration="wsHttp" name="wsHttpRead" bindingName="" contract="Xi.Contracts.IRead"/>

				<endpoint address="Write" binding="wsHttpBinding" bindingConfiguration="wsHttp" name="wsHttpWrite" bindingName="" contract="Xi.Contracts.IWrite"/>

				<endpoint address="Poll" binding="wsHttpBinding" bindingConfiguration="wsHttp" name="wsHttpPoll" bindingName="" contract="Xi.Contracts.IPoll"/>
                -->

				<!--basicHttpBinding Endpoints-->
				<!--basicHttpBinding Endpoints require certificates to be secured using https.-->
				<!--Since certificate administration is rather complicated, the basicHttpBindings are -->
				<!--commented out. -->
				<!--<endpoint address="BasicHttpResourceManagement" binding="basicHttpBinding" bindingConfiguration="basicHttp"
				name="basicHttpResourceManagement" bindingName="" contract="Xi.Contracts.IResourceManagement" />

				<endpoint address="BasicHttpRead" binding="basicHttpBinding" bindingConfiguration="basicHttp"
				name="basicHttpRead" bindingName="" contract="Xi.Contracts.IRead" />

				<endpoint address="BasicHttpWrite" binding="basicHttpBinding" bindingConfiguration="basicHttp"
				name="basicHttpWrite" bindingName="" contract="Xi.Contracts.IWrite" />

				<endpoint address="BasicHttpPoll" binding="basicHttpBinding" bindingConfiguration="basicHttp"
				name="basicHttpPoll" bindingName="" contract="Xi.Contracts.IPoll" />-->

				<!--webHttpBinding Endpoints-->
				<!--<endpoint address="RestRead" behaviorConfiguration="rest"
				binding="webHttpBinding" name="restRead" contract="Xi.Contracts.IRestRead" />-->

				<host>
					<baseAddresses>
						<!--This element defines the base addresses (URLs) for HTTP and TCP 
							endpoints.  The "XiServices" term in the URLs below is the default 
							name of the Xi Server.  Vendors are free to replace this term 
							with the name of their servers.
							
							Endpoints addresses defined above are appended to the 
							base addresses below to form a complete URL. For example, the 
							basicHttpBinding ResourceManagement endpoint above will have the 
							following complete URL:
							http://localhost:58080/XiServices/BasicHttpResourceManagement
							
							WCF allow servers to have more than one WCF application share an 
							HTTP port number as long as the paths following the port numbers are 
							different. For example two servers can share http port 61080 as 
							follows:
							"http://localhost:61080/XiServices1"
							"http://localhost:61080/XiServices2"
							
							However, WCF makes no such provision for TCP port numbers. Each 
							server will need to have its own TCP port number.  OPC Xi vendors 
							may contact the OPC Foundation to register TCP port numbers.

							Use of the example port numbers below may result in a conflict 
							if more than one Xi server on the same machine use these 
							port numbers and:
							(1) the port numbers are used for TCP.
							(2) the port numbers are used for HTTP and the path following 
							port numbers are the same. Therefore, it is recommended that 
							servers change at the least the path following HTTP port numbers.
							
							Note that it is still possible that another application uses 
							the assigned port number on a machine where the Xi server is 
							installed. In this case, the installation instructions should 
							include directions for re-assigning port numbers during installation.-->
						<!--<add baseAddress="net.pipe://localhost/SimcodeOpcNetServer"/>-->
						<add baseAddress="http://localhost:60080/SimcodeOpcNetServer"/>
						<add baseAddress="net.tcp://localhost:60085/SimcodeOpcNetServer"/>
					</baseAddresses>
				</host>
			</service>
		</services>

		<bindings>
			<!--In the bindings that follow, the maxBufferSize and maxReceivedMessageSize have been set 
				to their max values. Servers should set them according to the number and size of objects 
				they will be sending to the client in a single message -->

			<basicHttpBinding>
				<binding name="basicHttp" maxBufferSize="2147483647" maxReceivedMessageSize="2147483647">
					<!--Before using this basic Http Binding, the security mode should be set to 
						TransportWithMessageCredential and a corresponding https base address will 
						be necessary. This will require an SSL certificate to be installed. -->
					<!--<security mode="TransportWithMessageCredential">-->
					<!--This mode is provided only for testing. Do not use this in a live 
						environment since user name and password will be transferred i the clear.-->
					<security mode="TransportCredentialOnly">
						<!--Basic clientCredentialType requires the client application to 
							send in the user name and password. Make sure that security 
							mode="TransportWithMessageCredential" is set so the user name
							and password are not in the clear.-->
						<transport clientCredentialType="Basic"/>
					</security>
					<readerQuotas maxArrayLength="2147483647" maxDepth="2147483647" maxNameTableCharCount="2147483647" maxStringContentLength="2147483647"/>
				</binding>
				<binding name="basicHttpSecure" maxBufferSize="2147483647" maxReceivedMessageSize="2147483647">
					<security mode="Transport">
						<transport clientCredentialType="Basic"/>
					</security>
				</binding>
			</basicHttpBinding>

			<netNamedPipeBinding>
				<binding name="netPipe" maxBufferSize="2147483647" maxReceivedMessageSize="2147483647">
					<security mode="None">
						<transport protectionLevel="None"/>
					</security>
				</binding>
				<binding name="NetPipeSecure" maxBufferSize="2147483647" maxReceivedMessageSize="2147483647"/>
			</netNamedPipeBinding>

			<!-- netTcp Binding configurations -->

			<!--   <security mode="None"> -->
			<!--     Not valid for the ResourceDiscovery endpoint because  -->
			<!--     Xi Servers require authentication -->
			<!--   </security>-->

			<!--   <security mode="Transport"> -->
			<!--     <transport clientCredentialType="None"  - invalid -->
			<!--     Transport security uses encryption and requires authentication -->
			<!--   </security>-->

			<!--   <security mode="Transport"> -->
			<!--     <transport clientCredentialType="Windows"  - the default -->
			<!--     <message clientCredentialType              - ignored     -->
			<!--   </security>-->

			<!--   <security mode="Transport"> -->
			<!--     <transport clientCredentialType="Certificate"            -->
			<!--     <message clientCredentialType              - ignored     -->
			<!--     A Certificate is required in the "serviceBehaviors" section below,  -->
			<!--     under behavior name="XiServer".-->
			<!--        <serviceCredentials>
				           <serviceCertificate findValue="localhost" storeLocation="LocalMachine" storeName="My" x509FindType="FindBySubjectName" />
			            </serviceCredentials>-->
			<!--   </security>-->

			<!--   <security mode="Message"> -->
			<!--     <transport clientCredentialType="Windows"  - the default -->
			<!--     <message clientCredentialType="Windows"    - the default -->
			<!--   </security>-->

			<!--   <security mode="Message"> -->
			<!--     <transport clientCredentialType="Certificate" - ignored -->
			<!--     <message clientCredentialType="Windows"                 -->
			<!--   </security>-->

			<!--   <security mode="Message"> -->
			<!--     <transport clientCredentialType="None"        - ignored -->
			<!--     <message clientCredentialType="Windows"                 -->
			<!--   </security>-->

			<!--   <security mode="Message"> -->
			<!--     <transport clientCredentialType              - ignored     -->
			<!--     <message clientCredentialType="UserName"                   -->
			<!--     All application messages between the client and server are signed and encrypted-->
			<!--     A Certificate is therefore required in the "serviceBehaviors" section below,  -->
			<!--     under behavior name="XiServer".-->
			<!--     The Certificate is used by the service to authenticate itself to the -->
			<!--     client and to provide message protection.  e.g.-->
			<!--        <serviceCredentials>
				           <serviceCertificate findValue="localhost" storeLocation="LocalMachine" storeName="My" x509FindType="FindBySubjectName" />
			            </serviceCredentials>-->
			<!--   </security>-->

			<netTcpBinding>
				<binding name="netTcp" maxBufferSize="2147483647" maxReceivedMessageSize="2147483647" openTimeout="00:01:00" receiveTimeout="00:01:00" closeTimeout="00:01:00" sendTimeout="00:01:00">
					<security mode="None"/>
				</binding>
				<binding name="netTcpSecure" maxBufferSize="2147483647" maxReceivedMessageSize="2147483647"/>
			</netTcpBinding>

			<!-- wsHttp Binding configurations -->

			<!--   <security mode="None"> -->
			<!--     Not valid for the ResourceDiscovery endpoint because  -->
			<!--     Xi Servers require authentication -->
			<!--   </security>-->

			<!--   <security mode="Transport"> -->
			<!--     <transport clientCredentialType="None"  - invalid -->
			<!--     Transport security uses encryption and requires authentication -->
			<!--   </security>-->

			<!--   <security mode="Transport"> -->
			<!--     <transport clientCredentialType="Windows"  - the default -->
			<!--     <message clientCredentialType              - ignored     -->
			<!--   </security>-->

			<!--   <security mode="Transport"> -->
			<!--     <transport clientCredentialType="Certificate"            -->
			<!--     <message clientCredentialType              - ignored     -->
			<!--     A Certificate is required in the "serviceBehaviors" section below,  -->
			<!--     under behavior name="XiServer".-->
			<!--        <serviceCredentials>
				           <serviceCertificate findValue="localhost" storeLocation="LocalMachine" storeName="My" x509FindType="FindBySubjectName" />
			            </serviceCredentials>-->
			<!--   </security>-->

			<!--   <security mode="Message"> -->
			<!--     <transport clientCredentialType="Windows"  - the default -->
			<!--     <message clientCredentialType="Windows"    - the default -->
			<!--   </security>-->

			<!--   <security mode="Message"> -->
			<!--     <transport clientCredentialType="Certificate" - ignored -->
			<!--     <message clientCredentialType="Windows"                 -->
			<!--   </security>-->

			<!--   <security mode="Message"> -->
			<!--     <transport clientCredentialType="None"        - ignored -->
			<!--     <message clientCredentialType="Windows"                 -->
			<!--   </security>-->

			<!--   <security mode="Message"> -->
			<!--     <transport clientCredentialType="Ntlm"        - ignored -->
			<!--     <message clientCredentialType="Windows"                 -->
			<!--   </security>-->

			<!--   <security mode="Message"> -->
			<!--     <transport clientCredentialType              - ignored     -->
			<!--     <message clientCredentialType="UserName"                   -->
			<!--     All application messages between the client and server are signed and encrypted-->
			<!--     A Certificate is therefore required in the "serviceBehaviors" section below,  -->
			<!--     under behavior name="XiServer".-->
			<!--     The Certificate is used by the service to authenticate itself to the -->
			<!--     client and to provide message protection.  e.g.-->
			<!--        <serviceCredentials>
				           <serviceCertificate findValue="localhost" storeLocation="LocalMachine" storeName="My" x509FindType="FindBySubjectName" />
			            </serviceCredentials>-->
			<!--   </security>-->

			<wsHttpBinding>
				<binding name="wsHttp" maxReceivedMessageSize="2147483647">
					<security mode="Message">
						<message clientCredentialType="Windows"/>
					</security>
				</binding>
				<binding name="mexSecure">
					<security mode="Message"/>
				</binding>
			</wsHttpBinding>
		</bindings>

		<behaviors>
			<endpointBehaviors>
				<behavior name="rest">
					<webHttp/>
				</behavior>
			</endpointBehaviors>
			<serviceBehaviors>
				<behavior name="XiServer">
					<serviceDebug includeExceptionDetailInFaults="true"/>
					<serviceMetadata httpGetEnabled="true"/>
					<!--This is the max value. Servers should set this according to the 
						number of objects they will be sending to the client in a single message -->
					<dataContractSerializer maxItemsInObjectGraph="2147483647"/>
					<!--The two values below of "100" specify the maximum number of connections to the 
					Xi server and allow each connection to have one request in progress.  Since each 
					client application may have up to 4 concurrent connections with the server at the 
					same time (browse, read, write, subscribe), the value 100 conservatively sets the 
					max number of simultaneously connected clients to 25. To adjust this up or down, 
					multiply the desired max number of client applications by 4 and use the result 
					instead of 100 in both places. For example, to allow a max of 10 client applications 
					to be connnected to the DeltaV Xi server at the same time, set these values to 40.-->
					<serviceThrottling maxConcurrentCalls="100" maxConcurrentSessions="100"/>
				</behavior>
			</serviceBehaviors>
		</behaviors>
	</system.serviceModel>
<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8"/></startup></configuration>
